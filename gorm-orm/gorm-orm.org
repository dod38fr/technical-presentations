#+TITLE: Retour d'exp√©rience sur Gorm
#+author: Dominique Dumont
#+email: dominique@code-straight.fr
#+OPTIONS: ^:{}

* Qui suis-je ?

- Dominique Dumont (@dod38fr)
- Debian Developer depuis 2011
- Contributeur en Open-Source depuis 1996
- Freelance devops depuis 2020

* Gorm ?

- ORM en Go
- [[https://gorm.io/][GORM - The fantastic ORM library for Golang, aims to be developer friendly.]] üòÆ
- ORM: "Object Relational Mapper"
- la promesse:
  - pouvoir cr√©er une schema √† partir du code Go
  - transmettre les donn√©es de structures Go dans les tables SQL
  - et inversement
  - g√©rer aussi les structures imbriqu√©es

* Cr√©ation de mod√®le

- Gorm est capable de cr√©er la schema √† partir des structures Go
- Gorm est aussi capable d'exploiter une schema existante

#+begin_src go
type User struct {
  ID           uint           // Standard field for the primary key
  Name         string         // A regular string field
  Email        *string        // A pointer to a string, allowing for null values
  Age          uint8          // An unsigned 8-bit integer
  Birthday     *time.Time     // A pointer to time.Time, can be null
  MemberNumber sql.NullString // Uses sql.NullString to handle nullable strings
}
#+end_src

ü©π types =sql.NullString= pour des notions SQL (null type)

** Contraintes sur les champs

Le contraintes typiques de SQL sont faites avec des tags:

#+begin_src go
type User struct {
  ID           uint  
  Name         string  `gorm:"index"`         
  Email        *string `gorm:"unique"`
  Age          uint8
  Birthday     *time.Time
  MemberNumber sql.NullString
}
#+end_src

üëÅÔ∏è‚Äçüó®Ô∏è Connaissances en DB requises pour les tags

* Envoi de donn√©es dans les tables
** Avec ORM

#+begin_src go
  user := User{Name: "Jinzhu", Age: 18, Birthday: time.Now()}

  // pass pointer of data to Create
  result := db.Create(&user)

  result.Error        // returns error
  result.RowsAffected // returns inserted records count
#+end_src

Bien pratique sur les structures longues.

** Sans ORM

En C++:

#+begin_src c++
   SQLite::Statement author_q(pan_db, R"SQL(
     insert into author (name, address) values (?,?)
   )SQL");
   author_q.bind(1,name);
   author_q.bind(1,address);
   author_q.exec();
#+end_src

Verbeux mais explicite.

* Lire les donn√©es

** Avec ORM
#+begin_src go
  type User struct {
  	Name string
  	Age int
  	Birthday Time
  }
  var users []User

  db.Where("name LIKE ?", "%jin%").Find(&users)
  // SELECT * FROM users WHERE name LIKE '%jin%';
#+end_src

üëÅÔ∏è‚Äçüó®Ô∏è Connaissances en DB requises pour le =LIKE=

** Avec ORM

Pas forc√©ment intuitif:

#+begin_src go
    type User struct {
    	Name string
    	Age int
    	Birthday Time
    }
    var users []User

  db.Find(&users, []int{1,2,3})
  // SELECT * FROM users WHERE id IN (1,2,3);
#+end_src

** Sans ORM

#+begin_src c++
  SQLite::Statement is_read_q(pan_db, R"SQL(
    select is_read from article where message_id = ?
  )SQL");

  is_read_q.bind(1, message_id);
  
  while (is_read_q.executeStep()) {
    return is_read_q.getColumn(0).getInt() == 1;
  }
#+end_src

* Relations / Associations

** avec ORM - d√©claration
#+begin_src go
// User has and belongs to many languages, `user_languages` is the join table
type User struct {
  gorm.Model
  Languages []Language `gorm:"many2many:user_languages;"`
}

type Language struct {
  gorm.Model
  Name string
}
#+end_src

relation =many2many= d√©duite √† partir dy  type =Language=

üëÅÔ∏è‚Äçüó®Ô∏è notions SQL: =many2many=, =join table=

** avec ORM - lecture

#+begin_src go
  // Retrieve user list with eager loading languages
  var users []User
  err := db.Model(&User{}).Preload("Languages").
  	Find(&users).Error
#+end_src

- üéÉ m√©thode =Preload= pas intuitive

** sans ORM - lecture

#+begin_src c++
  SQLite::Statement read_group_q(pan_db, R"SQL(
    select g.name from `group` as g
    join article_group as ag on ag.group_id == g.id
    join article as a on ag.article_id == a.id
    where message_id = ?
  )SQL");
  read_group_q.bind(1, article->message_id);

  while (read_group_q.executeStep())
  {
      Quark grp (Quark(read_group_q.getColumn(0).getText()));
      group_to_changed_mids[grp].insert(article->message_id);
  }
#+end_src

- Verbeux,  mais explicite.
- on peut valider la requ√™te avec =sqlitebrowser= (ou =DBeaver=)

* Contourner Gorm

- pour les requ√™tes les plus complexes:
  - cr√©ation d'une structure ah-hoc pour r√©cup√©rer les r√©sultats
  - √©criture d'une requ√™te SQL 

#+begin_src go
  type Result struct {
    ID   int
    Name string
    Age  int
  }

  var result Result
  db.Raw("SELECT id, name, age FROM users WHERE name = ?",
  	"jinzhu").Scan(&result)
#+end_src


* Effets de bord

** Couplage

En voulant faire [[https://talks.freelancerepublik.com/principe-dry-dont-repeat-yourself/][DRY]], il est tentant d'avoir

#+begin_src go
type User struct {
  ID           uint  
  Name         string  `gorm:"index",json:"name"`         
  Email        *string `gorm:"unique",json"email"`
  Age          uint8
  Birthday     *time.Time
}
#+end_src

- la m√™me structure est utilis√©e pour l'API, le controlleur et l'adapteur de la DB
- une modification d'un c√¥t√© casse tout (couplage fort)

** Copie de stucture

- Pour √©viter les couplages: Avoir des structures d√©di√©es pour l'API,
  les controlleurs (=CtrlStruct=) et la DB (=DbStruct=)
- Avec ORM:
  - copier les donn√©es de =CtrlStruct= vers =DbStruct=
  - appeller l'ORM (qui copie les donn√©es de =DbStruct= pour les envoyer √† la DB)
- Sans ORM:
  - copier les donn√©es de =DbStruct= pour envoi √† la DB

** D√©boguage

En cas de probl√®me
- Besoin de lire les logs de Gorm qui montrent les requ√™tes SQL
- avec des tables de liaisons cr√©√©es par Gorm
- Besoin d'expertise SQL d√©boguer

* Conclusions 1/2

- ORM possible si:
  - beaucoup de colonnes dans les tables
  - la logique utilise toutes les colonnes
  - prototype
- ORM d√©conseill√©:
  - besoin de perf sur des requ√™tes complexes
  - lecture d'une colonne √† la fois

* Conclusions 2/2

- Si ORM, ne pas h√©siter √† contourner l'ORM et √©crire vos requ√™tes SQL
- Pour votre carri√®re:
  - Les connaissances SQL s'appliquent √† tous les langages (PHP, Python)
  - Les connaissances Gorm ne s'appliquent qu'√† Go.

 
* 
[[file:that_s_all_folks__by_surrimugge-d6rfav1.png]]

