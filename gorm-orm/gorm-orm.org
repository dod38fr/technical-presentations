#+TITLE: Retour d'exp√©rience sur Gorm
#+author: Dominique Dumont
#+email: dominique@code-straight.fr
#+OPTIONS: ^:{}

#+REVEAL_THEME: beige
#+REVEAL_EXTRA_CSS: ./pres.css
#+OPTIONS: toc:nil

* Qui suis-je ?

- Dominique Dumont (@dod38fr)
- Freelance devops depuis 2020
- Debian Developer depuis 2011
- Contributeur en Open-Source depuis 1996

* Gorm ?

- ORM: Object Relational Mapper
- ¬´[[https://gorm.io/][GORM - The fantastic ORM library for Golang, aims to be developer friendly.]]¬ª

** COMMENT la promesse:
  - pouvoir cr√©er une schema √† partir du code Go
  - transmettre les donn√©es de structures Go dans les tables SQL
  - et inversement
  - g√©rer aussi les structures imbriqu√©es

* COMMENT Cr√©ation de mod√®le

- Gorm est capable de cr√©er la schema √† partir des structures Go
- Gorm est aussi capable d'exploiter une schema existante

#+begin_src go
type User struct {
  ID           uint           // Standard field for the primary key
  Name         string         // A regular string field
  Email        *string        // A pointer to a string, allowing for null values
  Age          uint8          // An unsigned 8-bit integer
  Birthday     *time.Time     // A pointer to time.Time, can be null
  MemberNumber sql.NullString // Uses sql.NullString to handle nullable strings
}
#+end_src

ü©π types =sql.NullString= pour des notions SQL (null type)

** COMMENT Contraintes sur les champs

Le contraintes typiques de SQL sont faites avec des tags:

#+begin_src go
type User struct {
  ID           uint  
  Name         string  `gorm:"index"`         
  Email        *string `gorm:"unique"`
  Age          uint8
  Birthday     *time.Time
  MemberNumber sql.NullString
}
#+end_src

üëÅÔ∏è‚Äçüó®Ô∏è Connaissances en DB requises pour les tags

* Envoi de donn√©es dans les tables
** Avec ORM

#+begin_src go
  user := User{Name: "Jinzhu", Age: 18, Birthday: time.Now()}

  // pass pointer of data to Create
  result := db.Create(&user)
#+end_src

Bien pratique sur les structures longues.

** Sans ORM

En C++:

#+begin_src c++
   SQLite::Statement author_q(pan_db, R"SQL(
     insert into author (name, address) values (?,?)
   )SQL");
   author_q.bind(1,name);
   author_q.bind(1,address);
   author_q.exec();
#+end_src

Verbeux mais explicite.

* Lire les donn√©es

** Avec ORM
#+begin_src go
  type User struct {
  	Name string
  	Age int
  	Birthday Time
  }
  var users []User

  // Get all matched records
  db.Where("name == ?", "jinzhu").Find(&users)
  // SELECT * FROM users WHERE name <> 'jinzhu';
#+end_src

 ‚ö†Ô∏è¬´ =SELECT *= ¬ª sur des grandes tables

** Sans ORM

#+begin_src c++
  SQLite::Statement is_read_q(pan_db, R"SQL(
    select is_read from article where message_id = ?
  )SQL");

  is_read_q.bind(1, message_id);
  bool is_read;

  while (is_read_q.executeStep()) {
    is_read = is_read_q.getColumn(0).getInt() == 1;
  }
#+end_src

* Relations / Associations

** avec ORM - d√©claration
#+begin_src go
  // User has and belongs to many languages, `user_languages`
  // is the join table
  type User struct {
    gorm.Model
    Languages []Language `gorm:"many2many:user_languages;"`
  }

  type Language struct {
    gorm.Model
    Name string
  }
#+end_src

- relation =many2many= d√©duite √† partir du  type =Language=
- üëÅÔ∏è‚Äçüó®Ô∏è notions SQL requises: =many2many=, =join table=

** avec ORM - lecture

#+begin_src go
  // Retrieve user list with eager loading languages
  var users []User
  err := db.Model(&User{}).Preload("Languages").
  	Find(&users).Error
#+end_src

üéÉ m√©thode =Preload= pas intuitive

** sans ORM - lecture

#+begin_src c++
  SQLite::Statement read_group_q(pan_db, R"SQL(
    select g.name from `group` as g
    join article_group as ag on ag.group_id == g.id
    join article as a on ag.article_id == a.id
    where message_id = ?
  )SQL");
  read_group_q.bind(1, article->message_id);

  while (read_group_q.executeStep())
  {
      Quark grp (Quark(read_group_q.getColumn(0).getText()));
      group_to_changed_mids[grp].insert(article->message_id);
  }
#+end_src

- Verbeux,  mais explicite.
- üí°cr√©er la requ√™te avec =sqlitebrowser= (ou =DBeaver=)

* Astuce:  contourner Gorm

- pour les requ√™tes les plus complexes:
  - cr√©er une structure ah-hoc pour r√©cup√©rer les r√©sultats
  - √©crire la requ√™te en SQL 

#+begin_src go
  type Result struct {
    ID   int
    Name string
    Age  int
  }

  var result Result
  db.Raw("SELECT id, name, age FROM users WHERE name = ?",
  	"jinzhu").Scan(&result)
#+end_src

* Effets de bord
** Couplage

En voulant faire [[https://talks.freelancerepublik.com/principe-dry-dont-repeat-yourself/][DRY]], il est tentant d'avoir

#+begin_src go
type User struct {
  ID           uint  
  Name         string  `gorm:"index",json:"name"`         
  Email        *string `gorm:"unique",json"email"`
  Age          uint8
  Birthday     *time.Time
}
#+end_src

- la m√™me structure est utilis√©e pour l'API, le contr√¥leur et l'adaptateur de la DB
- une modification d'un c√¥t√© casse tout (couplage fort)

** D√©boguage

En cas de probl√®me:
- lire les logs de Gorm qui montrent les requ√™tes SQL
- avec des tables de liaisons cr√©√©es par Gorm
- üòë besoin d'expertise SQL pour interpr√©ter les logs

** Perf: copies de structures

- Pour √©viter les couplages: cr√©er des structures d√©di√©es pour:
  - l'API,
  - les controleurs (=CtrlStruct=)
  - la DB (=DbStruct=)
- Traitement:
  - 2 copies avec ORM:
    - de =CtrlStruct= vers =DbStruct=
    - de =DbStruct= vers DB API
  - 1 copie sans ORM:
    - de =CtrlStruct= vers DB API

* Conclusions 1/2

- ORM possible si:
  - beaucoup de colonnes dans les tables
  - la logique utilise toutes les colonnes
  - prototype
- ORM d√©conseill√©:
  - besoin de perf sur des requ√™tes complexes
  - lecture de quelques colonnes √† la fois

* Conclusions 2/2

- Si ORM, ne pas h√©siter √† contourner l'ORM et √©crire vos requ√™tes SQL
- Pour votre carri√®re:
  - Les connaissances SQL s'appliquent √† tous les langages (PHP, Python)
  - Les connaissances Gorm ne s'appliquent qu'√† Go.

 
* 
[[file:that_s_all_folks__by_surrimugge-d6rfav1.png]]

